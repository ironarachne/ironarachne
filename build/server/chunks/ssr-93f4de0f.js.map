{"version":3,"file":"ssr-93f4de0f.js","sources":["../../../../node_modules/svelte/src/runtime/internal/ssr.js","../../../../node_modules/svelte/src/runtime/internal/each.js","../../../../node_modules/svelte/src/runtime/internal/lifecycle.js","../../../../node_modules/svelte/src/runtime/internal/utils.js"],"sourcesContent":["import { set_current_component, current_component } from './lifecycle.js';\nimport { run_all, blank_object } from './utils.js';\nimport { boolean_attributes } from '../../shared/boolean_attributes.js';\nimport { ensure_array_like } from './each.js';\nexport { is_void } from '../../shared/utils/names.js';\n\nexport const invalid_attribute_name_character =\n\t/[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\n\n/** @returns {string} */\nexport function spread(args, attrs_to_add) {\n\tconst attributes = Object.assign({}, ...args);\n\tif (attrs_to_add) {\n\t\tconst classes_to_add = attrs_to_add.classes;\n\t\tconst styles_to_add = attrs_to_add.styles;\n\t\tif (classes_to_add) {\n\t\t\tif (attributes.class == null) {\n\t\t\t\tattributes.class = classes_to_add;\n\t\t\t} else {\n\t\t\t\tattributes.class += ' ' + classes_to_add;\n\t\t\t}\n\t\t}\n\t\tif (styles_to_add) {\n\t\t\tif (attributes.style == null) {\n\t\t\t\tattributes.style = style_object_to_string(styles_to_add);\n\t\t\t} else {\n\t\t\t\tattributes.style = style_object_to_string(\n\t\t\t\t\tmerge_ssr_styles(attributes.style, styles_to_add)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tlet str = '';\n\tObject.keys(attributes).forEach((name) => {\n\t\tif (invalid_attribute_name_character.test(name)) return;\n\t\tconst value = attributes[name];\n\t\tif (value === true) str += ' ' + name;\n\t\telse if (boolean_attributes.has(name.toLowerCase())) {\n\t\t\tif (value) str += ' ' + name;\n\t\t} else if (value != null) {\n\t\t\tstr += ` ${name}=\"${value}\"`;\n\t\t}\n\t});\n\treturn str;\n}\n\n/** @returns {{}} */\nexport function merge_ssr_styles(style_attribute, style_directive) {\n\tconst style_object = {};\n\tfor (const individual_style of style_attribute.split(';')) {\n\t\tconst colon_index = individual_style.indexOf(':');\n\t\tconst name = individual_style.slice(0, colon_index).trim();\n\t\tconst value = individual_style.slice(colon_index + 1).trim();\n\t\tif (!name) continue;\n\t\tstyle_object[name] = value;\n\t}\n\tfor (const name in style_directive) {\n\t\tconst value = style_directive[name];\n\t\tif (value) {\n\t\t\tstyle_object[name] = value;\n\t\t} else {\n\t\t\tdelete style_object[name];\n\t\t}\n\t}\n\treturn style_object;\n}\n\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n * @param {unknown} value\n * @returns {string}\n */\nexport function escape(value, is_attr = false) {\n\tconst str = String(value);\n\tconst pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n\tpattern.lastIndex = 0;\n\tlet escaped = '';\n\tlet last = 0;\n\twhile (pattern.test(str)) {\n\t\tconst i = pattern.lastIndex - 1;\n\t\tconst ch = str[i];\n\t\tescaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '\"' ? '&quot;' : '&lt;');\n\t\tlast = i + 1;\n\t}\n\treturn escaped + str.substring(last);\n}\n\nexport function escape_attribute_value(value) {\n\t// keep booleans, null, and undefined for the sake of `spread`\n\tconst should_escape = typeof value === 'string' || (value && typeof value === 'object');\n\treturn should_escape ? escape(value, true) : value;\n}\n\n/** @returns {{}} */\nexport function escape_object(obj) {\n\tconst result = {};\n\tfor (const key in obj) {\n\t\tresult[key] = escape_attribute_value(obj[key]);\n\t}\n\treturn result;\n}\n\n/** @returns {string} */\nexport function each(items, fn) {\n\titems = ensure_array_like(items);\n\tlet str = '';\n\tfor (let i = 0; i < items.length; i += 1) {\n\t\tstr += fn(items[i], i);\n\t}\n\treturn str;\n}\n\nexport const missing_component = {\n\t$$render: () => ''\n};\n\nexport function validate_component(component, name) {\n\tif (!component || !component.$$render) {\n\t\tif (name === 'svelte:component') name += ' this={...}';\n\t\tthrow new Error(\n\t\t\t`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`\n\t\t);\n\t}\n\treturn component;\n}\n\n/** @returns {string} */\nexport function debug(file, line, column, values) {\n\tconsole.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n\tconsole.log(values); // eslint-disable-line no-console\n\treturn '';\n}\n\nlet on_destroy;\n\n/** @returns {{ render: (props?: {}, { $$slots, context }?: { $$slots?: {}; context?: Map<any, any>; }) => { html: any; css: { code: string; map: any; }; head: string; }; $$render: (result: any, props: any, bindings: any, slots: any, context: any) => any; }} */\nexport function create_ssr_component(fn) {\n\tfunction $$render(result, props, bindings, slots, context) {\n\t\tconst parent_component = current_component;\n\t\tconst $$ = {\n\t\t\ton_destroy,\n\t\t\tcontext: new Map(context || (parent_component ? parent_component.$$.context : [])),\n\t\t\t// these will be immediately discarded\n\t\t\ton_mount: [],\n\t\t\tbefore_update: [],\n\t\t\tafter_update: [],\n\t\t\tcallbacks: blank_object()\n\t\t};\n\t\tset_current_component({ $$ });\n\t\tconst html = fn(result, props, bindings, slots);\n\t\tset_current_component(parent_component);\n\t\treturn html;\n\t}\n\treturn {\n\t\trender: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n\t\t\ton_destroy = [];\n\t\t\tconst result = { title: '', head: '', css: new Set() };\n\t\t\tconst html = $$render(result, props, {}, $$slots, context);\n\t\t\trun_all(on_destroy);\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\tcss: {\n\t\t\t\t\tcode: Array.from(result.css)\n\t\t\t\t\t\t.map((css) => css.code)\n\t\t\t\t\t\t.join('\\n'),\n\t\t\t\t\tmap: null // TODO\n\t\t\t\t},\n\t\t\t\thead: result.title + result.head\n\t\t\t};\n\t\t},\n\t\t$$render\n\t};\n}\n\n/** @returns {string} */\nexport function add_attribute(name, value, boolean) {\n\tif (value == null || (boolean && !value)) return '';\n\tconst assignment = boolean && value === true ? '' : `=\"${escape(value, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/** @returns {string} */\nexport function add_classes(classes) {\n\treturn classes ? ` class=\"${classes}\"` : '';\n}\n\n/** @returns {string} */\nfunction style_object_to_string(style_object) {\n\treturn Object.keys(style_object)\n\t\t.filter((key) => style_object[key])\n\t\t.map((key) => `${key}: ${escape_attribute_value(style_object[key])};`)\n\t\t.join(' ');\n}\n\n/** @returns {string} */\nexport function add_styles(style_object) {\n\tconst styles = style_object_to_string(style_object);\n\treturn styles ? ` style=\"${styles}\"` : '';\n}\n","import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n"],"names":[],"mappings":"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"}