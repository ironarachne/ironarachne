{"version":3,"file":"hooks.server.js","sources":["../../../../node_modules/@sveltejs/kit/src/exports/hooks/sequence.js","../../../../src/hooks.server.ts"],"sourcesContent":["/**\n * A helper function for sequencing multiple `handle` calls in a middleware-like manner.\n * The behavior for the `handle` options is as follows:\n * - `transformPageChunk` is applied in reverse order and merged\n * - `preload` is applied in forward order, the first option \"wins\" and no `preload` options after it are called\n * - `filterSerializedResponseHeaders` behaves the same as `preload`\n *\n * ```js\n * /// file: src/hooks.server.js\n * import { sequence } from '@sveltejs/kit/hooks';\n *\n * /// type: import('@sveltejs/kit').Handle\n * async function first({ event, resolve }) {\n * \tconsole.log('first pre-processing');\n * \tconst result = await resolve(event, {\n * \t\ttransformPageChunk: ({ html }) => {\n * \t\t\t// transforms are applied in reverse order\n * \t\t\tconsole.log('first transform');\n * \t\t\treturn html;\n * \t\t},\n * \t\tpreload: () => {\n * \t\t\t// this one wins as it's the first defined in the chain\n * \t\t\tconsole.log('first preload');\n * \t\t}\n * \t});\n * \tconsole.log('first post-processing');\n * \treturn result;\n * }\n *\n * /// type: import('@sveltejs/kit').Handle\n * async function second({ event, resolve }) {\n * \tconsole.log('second pre-processing');\n * \tconst result = await resolve(event, {\n * \t\ttransformPageChunk: ({ html }) => {\n * \t\t\tconsole.log('second transform');\n * \t\t\treturn html;\n * \t\t},\n * \t\tpreload: () => {\n * \t\t\tconsole.log('second preload');\n * \t\t},\n * \t\tfilterSerializedResponseHeaders: () => {\n * \t\t\t// this one wins as it's the first defined in the chain\n *    \t\tconsole.log('second filterSerializedResponseHeaders');\n * \t\t}\n * \t});\n * \tconsole.log('second post-processing');\n * \treturn result;\n * }\n *\n * export const handle = sequence(first, second);\n * ```\n *\n * The example above would print:\n *\n * ```\n * first pre-processing\n * first preload\n * second pre-processing\n * second filterSerializedResponseHeaders\n * second transform\n * first transform\n * second post-processing\n * first post-processing\n * ```\n *\n * @param {...import('@sveltejs/kit').Handle} handlers The chain of `handle` functions\n * @returns {import('@sveltejs/kit').Handle}\n */\nexport function sequence(...handlers) {\n\tconst length = handlers.length;\n\tif (!length) return ({ event, resolve }) => resolve(event);\n\n\treturn ({ event, resolve }) => {\n\t\treturn apply_handle(0, event, {});\n\n\t\t/**\n\t\t * @param {number} i\n\t\t * @param {import('@sveltejs/kit').RequestEvent} event\n\t\t * @param {import('@sveltejs/kit').ResolveOptions | undefined} parent_options\n\t\t * @returns {import('types').MaybePromise<Response>}\n\t\t */\n\t\tfunction apply_handle(i, event, parent_options) {\n\t\t\tconst handle = handlers[i];\n\n\t\t\treturn handle({\n\t\t\t\tevent,\n\t\t\t\tresolve: (event, options) => {\n\t\t\t\t\t/** @type {import('@sveltejs/kit').ResolveOptions['transformPageChunk']} */\n\t\t\t\t\tconst transformPageChunk = async ({ html, done }) => {\n\t\t\t\t\t\tif (options?.transformPageChunk) {\n\t\t\t\t\t\t\thtml = (await options.transformPageChunk({ html, done })) ?? '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parent_options?.transformPageChunk) {\n\t\t\t\t\t\t\thtml = (await parent_options.transformPageChunk({ html, done })) ?? '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn html;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {import('@sveltejs/kit').ResolveOptions['filterSerializedResponseHeaders']} */\n\t\t\t\t\tconst filterSerializedResponseHeaders =\n\t\t\t\t\t\tparent_options?.filterSerializedResponseHeaders ??\n\t\t\t\t\t\toptions?.filterSerializedResponseHeaders;\n\n\t\t\t\t\t/** @type {import('@sveltejs/kit').ResolveOptions['preload']} */\n\t\t\t\t\tconst preload = parent_options?.preload ?? options?.preload;\n\n\t\t\t\t\treturn i < length - 1\n\t\t\t\t\t\t? apply_handle(i + 1, event, {\n\t\t\t\t\t\t\t\ttransformPageChunk,\n\t\t\t\t\t\t\t\tfilterSerializedResponseHeaders,\n\t\t\t\t\t\t\t\tpreload\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n","import { handleErrorWithSentry, sentryHandle } from \"@sentry/sveltekit\";\nimport * as Sentry from \"@sentry/sveltekit\";\nimport { sequence } from \"@sveltejs/kit/hooks\";\n\nSentry.init({\n  dsn: \"https://2de60e90eb93636e5aec6e3e0d12205f@o269960.ingest.sentry.io/4505664923041792\",\n  tracesSampleRate: 1.0,\n});\n\n// If you have custom handlers, make sure to place them after `sentryHandle()` in the `sequence` function.\nexport const handle = sequence(sentryHandle());\n\n// If you have a custom error handler, pass it to `handleErrorWithSentry`\nexport const handleError = handleErrorWithSentry();\n"],"names":["event","handle"],"mappings":";;;AAoEO,SAAS,YAAY,UAAU;AACrC,QAAM,SAAS,SAAS;AACxB,MAAI,CAAC;AAAQ,WAAO,CAAC,EAAE,OAAO,cAAc,QAAQ,KAAK;AAEzD,SAAO,CAAC,EAAE,OAAO,cAAc;AAC9B,WAAO,aAAa,GAAG,OAAO,CAAE,CAAA;AAQhC,aAAS,aAAa,GAAGA,QAAO,gBAAgB;AAC/C,YAAMC,UAAS,SAAS,CAAC;AAEzB,aAAOA,QAAO;AAAA,QACb,OAAAD;AAAA,QACA,SAAS,CAACA,QAAO,YAAY;AAE5B,gBAAM,qBAAqB,OAAO,EAAE,MAAM,KAAI,MAAO;AACpD,gBAAI,SAAS,oBAAoB;AAChC,qBAAQ,MAAM,QAAQ,mBAAmB,EAAE,MAAM,KAAI,CAAE,KAAM;AAAA,YAC7D;AAED,gBAAI,gBAAgB,oBAAoB;AACvC,qBAAQ,MAAM,eAAe,mBAAmB,EAAE,MAAM,KAAI,CAAE,KAAM;AAAA,YACpE;AAED,mBAAO;AAAA,UACb;AAGK,gBAAM,kCACL,gBAAgB,mCAChB,SAAS;AAGV,gBAAM,UAAU,gBAAgB,WAAW,SAAS;AAEpD,iBAAO,IAAI,SAAS,IACjB,aAAa,IAAI,GAAGA,QAAO;AAAA,YAC3B;AAAA,YACA;AAAA,YACA;AAAA,UACR,CAAQ,IACA,QAAQA,QAAO,EAAE,oBAAoB,iCAAiC,QAAS,CAAA;AAAA,QAClF;AAAA,MACL,CAAI;AAAA,IACD;AAAA,EACH;AACA;;;ACnHA,OAAA,KAAA;AAAA,EAAY,KAAA;AAAA,EACL,kBAAA;AAEP,CAAA;AAGO,MAAA,SAAA,SAAA,cAAA;AAGA,MAAA,cAAA,sBAAA;","x_google_ignoreList":[0]}